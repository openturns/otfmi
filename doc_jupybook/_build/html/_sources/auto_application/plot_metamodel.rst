
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_application/plot_metamodel.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_application_plot_metamodel.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_application_plot_metamodel.py:


Metamodel a FMU time-dependent output
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 6-38

We are interested in the evolution of an epidemic through a
population (for instance, Covid!). We have an epidemiologic model describing
the epidemic dynamics. More precisely, we focus on the evolution of the number
of people infected by the disease.

.. image:: /_static/epid.png
   :width: 400px
   :height: 300px
   :scale: 100 %
   :alt: alternate text
   :align: center

--------

See the epidemiological model :doc:`here<../fmus/epid>`.

--------


**To decrease the model simulation costs, let's create a metamodel.**

Metamodeling a model which output depends on time is a difficult problem. We
will combine two methods: Karhunen-Loeve dimension reduction should precede the Kriging metamodeling.

We will proceed the following way:

- simulate the FMU *n* times on a design of experiment,
- concentrate the information of the time-dependent output via Karhunen-Loeve,
- metamodel the Karhunen-Loeve coefficients.

The composition of the coefficients metamodel with the inverse
Karhunen-Loeve will make the global metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 40-42

Create the metamodel
++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 45-49

We load the FMU as a FMUPointToFieldFunction (see the
:doc:`tutorial<../_generated/otfmi.FMUPointToFieldFunction>`). We concentrate
on the first time unit of the epidemiological model output. The single
uncertain input of the model is the ``Ã¬nfection_rate``.

.. GENERATED FROM PYTHON SOURCE LINES 49-67

.. code-block:: Python


    import otfmi.example.utility
    import openturns as ot
    import openturns.viewer as viewer

    path_fmu = otfmi.example.utility.get_path_fmu("epid")
    mesh = ot.RegularGrid(0.0, 0.05, 20)
    meshSample = mesh.getVertices()

    function = otfmi.FMUPointToFieldFunction(
        mesh,
        path_fmu,
        inputs_fmu=["infection_rate"],
        outputs_fmu=["infected"],
        start_time=0.0,
        final_time=1.0,
    )








.. GENERATED FROM PYTHON SOURCE LINES 68-71

We create a Monte-Carlo design of experiment, on which we
simulate the FMU.
The simulation inputs and outputs will be used to train the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 71-84

.. code-block:: Python


    inputLaw = ot.Uniform(0.001, 0.01)
    inputSample = inputLaw.getSample(30)
    outputFMUSample = function(inputSample)

    graph = outputFMUSample.draw().getGraph(0, 0)
    graph.setTitle("FMU simulations")
    graph.setXTitle("Time")
    graph.setYTitle("Number of infected")
    graph.setLegends(["{:.3f}".format(line[0]) for line in inputSample])
    view = viewer.View(graph, legend_kw={"title": "infection rate", "loc": "upper left"})
    view.ShowAll()




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_001.png
   :alt: FMU simulations
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 85-86

We define a function to visualize the upcoming Karhunen-Loevem modes.

.. GENERATED FROM PYTHON SOURCE LINES 86-111

.. code-block:: Python



    def drawKL(scaledKL, KLev, mesh, title="Scaled KL modes"):
        graph_modes = scaledKL.drawMarginal()
        graph_modes.setTitle(title + " scaled KL modes")
        graph_modes.setXTitle("$x$")
        graph_modes.setYTitle(r"$\sqrt{\lambda_i}\phi_i$")
        data_ev = [[i, KLev[i]] for i in range(scaledKL.getSize())]
        graph_ev = ot.Graph()
        graph_ev.add(ot.Curve(data_ev))
        graph_ev.add(ot.Cloud(data_ev))
        graph_ev.setTitle(title + " KL eigenvalues")
        graph_ev.setXTitle("$k$")
        graph_ev.setYTitle(r"$\lambda_i$")
        graph_ev.setAxes(True)
        graph_ev.setGrid(True)
        graph_ev.setLogScale(2)
        bb = graph_ev.getBoundingBox()
        lower = bb.getLowerBound()
        lower[1] = 1.0e-7
        bb = ot.Interval(lower, bb.getUpperBound())
        graph_ev.setBoundingBox(bb)
        return graph_modes, graph_ev









.. GENERATED FROM PYTHON SOURCE LINES 112-115

We compute the Karhunen-Loeve decomposition of the model outputs.
The underlying assumption is that these outputs are realizations of a
stochastic process.

.. GENERATED FROM PYTHON SOURCE LINES 115-121

.. code-block:: Python


    threshold = 0.0001
    algoKL = ot.KarhunenLoeveSVDAlgorithm(outputFMUSample, threshold)
    algoKL.run()
    resultKL = algoKL.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 122-123

Let be curious and plot the Karhunen-Loeve modes:

.. GENERATED FROM PYTHON SOURCE LINES 123-129

.. code-block:: Python

    phi_Y = resultKL.getScaledModesAsProcessSample()
    lambda_Y = resultKL.getEigenvalues()
    graph_modes_Y, graph_ev_Y = drawKL(phi_Y, lambda_Y, mesh, "Y")
    view = viewer.View(graph_modes_Y)
    view.ShowAll()




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_002.png
   :alt: Y scaled KL modes
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 130-132

Now that Karhunen-Loeve algorithm is trained, we can project them
in the smaller-dimension space:

.. GENERATED FROM PYTHON SOURCE LINES 132-136

.. code-block:: Python

    projectionSample = resultKL.project(outputFMUSample)
    n_mode = projectionSample.getDimension()
    print("Karhunen-Loeve projection is dimension {}".format(n_mode))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Karhunen-Loeve projection is dimension 3




.. GENERATED FROM PYTHON SOURCE LINES 137-140

We keep on following our road map, by metamodeling the projection
of the curves on the smaller-dimension space.
We metamodel the Karhunen-Loeve coefficients using ordinary Kriging.

.. GENERATED FROM PYTHON SOURCE LINES 140-153

.. code-block:: Python

    dim = inputSample.getDimension()  # only 1 input dimension
    univb = ot.ConstantBasisFactory(dim).build()  # univariate basis
    coll = [ot.AggregatedFunction([univb.build(i)] * n_mode) for i in range(univb.getSize())]
    basis = ot.Basis(coll)  # multivariate basis
    covarianceModel = ot.SquaredExponential(dim)
    covarianceModel = ot.TensorizedCovarianceModel([covarianceModel] * n_mode)


    algo = ot.KrigingAlgorithm(inputSample, projectionSample, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 154-156

We have created all pieces for a "PointToField" metamodel. Let put these
pieces together:

.. GENERATED FROM PYTHON SOURCE LINES 156-165

.. code-block:: Python



    def globalMetamodel(sample):
        emulatedCoefficients = metamodel(sample)
        restoreFunction = ot.KarhunenLoeveLifting(resultKL)
        emulatedProcessSample = restoreFunction(emulatedCoefficients)
        return emulatedProcessSample









.. GENERATED FROM PYTHON SOURCE LINES 166-168

Validate the metamodel
++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 171-173

We create a new Monte-Carlo design of experiment. On this design of
experiment, the FMU is simulated as well as the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 173-178

.. code-block:: Python


    inputTestSample = inputLaw.getSample(10)
    outputFMUTestSample = function(inputTestSample)
    outputMetamodelTestSample = globalMetamodel(inputTestSample)








.. GENERATED FROM PYTHON SOURCE LINES 179-180

First, we have a visual check:

.. GENERATED FROM PYTHON SOURCE LINES 180-200

.. code-block:: Python


    gridLayout = ot.GridLayout(1, 2)

    graph1 = outputFMUTestSample.draw().getGraph(0, 0)
    graph1.setTitle("FMU simulations")
    graph2 = outputMetamodelTestSample.draw().getGraph(0, 0)
    graph2.setTitle("Metamodel")

    for graph in [graph1, graph2]:
        graph.setXTitle("Time")
        graph.setYTitle("Number of infected")
        graph.setLegends(["{:.3f}".format(line[0]) for line in inputSample])

    gridLayout.setGraph(0, 0, graph1)
    gridLayout.setGraph(0, 1, graph2)
    view = viewer.View(
        gridLayout, legend_kw={"title": "infection rate", "loc": "upper left"}
    )
    view.ShowAll()




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_003.png
   :alt: , FMU simulations, Metamodel
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 201-202

We validate the pertinence of Karhunen-Loeve decomposition:

.. GENERATED FROM PYTHON SOURCE LINES 202-207

.. code-block:: Python


    validationKL = ot.KarhunenLoeveValidation(outputFMUTestSample, resultKL)
    graph = validationKL.computeResidualMean().draw()
    ot.Show(graph)




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_004.png
   :alt: KL residual mean - 0 marginal
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 208-210

As the epidemiological model considers a population size of 700, the residual
mean error on the field is acceptable.

.. GENERATED FROM PYTHON SOURCE LINES 212-214

We validate the Kriging (using the Karhunen-Loeve coefficients of the test
sample):

.. GENERATED FROM PYTHON SOURCE LINES 214-224

.. code-block:: Python


    projectFunction = ot.KarhunenLoeveProjection(resultKL)
    coefficientSample = projectFunction(outputFMUTestSample)

    validationKriging = ot.MetaModelValidation(
        inputTestSample, coefficientSample, metamodel
    )
    Q2 = validationKriging.computePredictivityFactor()[0]
    print(Q2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0.9999949332681868




.. GENERATED FROM PYTHON SOURCE LINES 225-229

The predictivity factor is very close to 1, which is satisfying.
Further statistical tests exist in
`OpenTURNS <http://openturns.github.io/openturns/master/contents.html>`_ to
assert the quality of the obtained metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 231-242

----------------------

The ``globalMetamodel`` (computationnally faster than the FMU) created with
the above script can now be used as a computationnally much cheaper
substitute to the FMU for

- `sensitivity analysis <openturns.github.io/openturns/latest/auto_reliability_sensitivity/index.html#sensitivity-analysis>`_,
- `parameter inference <openturns.github.io/openturns/latest/auto_calibration/index.html#bayesian-calibration>`_,
- `estimate a failure probability <openturns.github.io/openturns/latest/auto_reliability_sensitivity/index.html#reliability>`_,

etc.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.003 seconds)


.. _sphx_glr_download_auto_application_plot_metamodel.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_metamodel.ipynb <plot_metamodel.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_metamodel.py <plot_metamodel.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_metamodel.zip <plot_metamodel.zip>`
