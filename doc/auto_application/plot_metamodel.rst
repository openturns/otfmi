
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_application/plot_metamodel.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_application_plot_metamodel.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_application_plot_metamodel.py:


Metamodel a FMU time-dependent output
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 12-44

We are interested in the evolution of an epidemic through a
population (for instance, Covid!). We have an epidemiologic model describing
the epidemic dynamics. More precisely, we focus on the evolution of the number
of people infected by the disease.

.. image:: /_static/epid.png
   :width: 400px
   :height: 300px
   :scale: 100 %
   :alt: alternate text
   :align: center

--------

See the epidemiological model :doc:`here<../fmus/epid>`.

--------


**To decrease the model simulation costs, let's create a metamodel.**

Metamodeling a model which output depends on time is a difficult problem. We
will combine two methods: Karhunen-Loeve dimension reduction should precede the Kriging metamodeling.

We will proceed the following way:

- simulate the FMU *n* times on a design of experiment,
- concentrate the information of the time-dependent output via Karhunen-Loeve,
- metamodel the Karhunen-Loeve coefficients.

The composition of the coefficients metamodel with the inverse
Karhunen-Loeve will make the global metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 46-48

Create the metamodel
++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 51-55

We load the FMU as a FMUPointToFieldFunction (see the
:doc:`tutorial<../_generated/otfmi.FMUPointToFieldFunction>`). We concentrate
on the first time unit of the epidemiological model output. The single
uncertain input of the model is the ``Ã¬nfection_rate``.

.. GENERATED FROM PYTHON SOURCE LINES 55-71

.. code-block:: default


    import otfmi.example.utility
    path_fmu = otfmi.example.utility.get_path_fmu("epid")

    import openturns as ot
    mesh = ot.RegularGrid(0.0, 0.05, 20)  
    meshSample = mesh.getVertices()

    function = otfmi.FMUPointToFieldFunction(
        mesh,
        path_fmu,
        inputs_fmu=["infection_rate"],
        outputs_fmu=["infected"],
        start_time=0.0,
        final_time=1.0)








.. GENERATED FROM PYTHON SOURCE LINES 72-75

We create a Monte-Carlo design of experiment, on which we
simulate the FMU.
The simulation inputs and outputs will be used to train the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 75-92

.. code-block:: default


    inputLaw = ot.Uniform(0.001, 0.01)
    inputSample = inputLaw.getSample(30)
    outputFMUSample = function(inputSample)

    import openturns.viewer as viewer

    graph = outputFMUSample.draw().getGraph(0, 0)
    graph.setTitle("FMU simulations")
    graph.setXTitle("Time")
    graph.setYTitle("Number of infected")
    graph.setLegends(["{:.3f}".format(line[0]) for line in inputSample])
    view = viewer.View(graph,
        legend_kw={"title": "infection rate",
        "loc": "upper left"})
    view.ShowAll()




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_001.png
   :alt: FMU simulations
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 93-94

We define a function to visualize the upcoming Karhunen-Loevem modes.

.. GENERATED FROM PYTHON SOURCE LINES 94-118

.. code-block:: default


    def drawKL(scaledKL, KLev, mesh, title="Scaled KL modes"):
        graph_modes = scaledKL.drawMarginal()
        graph_modes.setTitle(title + " scaled KL modes")
        graph_modes.setXTitle('$x$')
        graph_modes.setYTitle(r'$\sqrt{\lambda_i}\phi_i$')
        data_ev = [[i, KLev[i]] for i in range(scaledKL.getSize())]
        graph_ev = ot.Graph()
        graph_ev.add(ot.Curve(data_ev))
        graph_ev.add(ot.Cloud(data_ev))
        graph_ev.setTitle(title + " KL eigenvalues")
        graph_ev.setXTitle('$k$')
        graph_ev.setYTitle(r'$\lambda_i$')
        graph_ev.setAxes(True)
        graph_ev.setGrid(True)
        graph_ev.setLogScale(2)
        bb = graph_ev.getBoundingBox()
        lower = bb.getLowerBound()
        lower[1] = 1.0e-7
        bb = ot.Interval(lower, bb.getUpperBound())
        graph_ev.setBoundingBox(bb)
        return graph_modes, graph_ev









.. GENERATED FROM PYTHON SOURCE LINES 119-122

We compute the Karhunen-Loeve decomposition of the model outputs.
The underlying assumption is that these outputs are realizations of a
stochastic process.

.. GENERATED FROM PYTHON SOURCE LINES 122-128

.. code-block:: default


    threshold = 0.0001
    algoKL = ot.KarhunenLoeveSVDAlgorithm(outputFMUSample, threshold)
    algoKL.run()
    resultKL = algoKL.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 129-130

Let be curious and plot the Karhunen-Loeve modes:

.. GENERATED FROM PYTHON SOURCE LINES 130-136

.. code-block:: default

    phi_Y = resultKL.getScaledModesAsProcessSample()
    lambda_Y = resultKL.getEigenvalues()
    graph_modes_Y, graph_ev_Y = drawKL(phi_Y, lambda_Y, mesh, "Y")
    view = viewer.View(graph_modes_Y)
    view.ShowAll()




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_002.png
   :alt: Y scaled KL modes
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 137-139

Now that Karhunen-Loeve algorithm is trained, we can project them
in the smaller-dimension space:

.. GENERATED FROM PYTHON SOURCE LINES 139-143

.. code-block:: default

    projectionSample = resultKL.project(outputFMUSample)
    n_mode = projectionSample.getDimension()
    print("Karhunen-Loeve projection is dimension {}".format(n_mode))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Karhunen-Loeve projection is dimension 3




.. GENERATED FROM PYTHON SOURCE LINES 144-147

We keep on following our road map, by metamodeling the projection
of the curves on the smaller-dimension space.
We metamodel the Karhunen-Loeve coefficients using ordinary Kriging.

.. GENERATED FROM PYTHON SOURCE LINES 147-159

.. code-block:: default


    dim = inputSample.getDimension()  # only 1 input dimension
    basis = ot.ConstantBasisFactory(dim).build()
    covarianceModel = ot.SquaredExponential(dim)  


    algo = ot.KrigingAlgorithm(
        inputSample, projectionSample, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 160-162

We have created all pieces for a "PointToField" metamodel. Let put these
pieces together:

.. GENERATED FROM PYTHON SOURCE LINES 162-169

.. code-block:: default


    def globalMetamodel(sample):
        emulatedCoefficients = metamodel(sample)
        restoreFunction = ot.KarhunenLoeveLifting(resultKL)
        emulatedProcessSample = restoreFunction(emulatedCoefficients)
        return emulatedProcessSample








.. GENERATED FROM PYTHON SOURCE LINES 170-172

Validate the metamodel
++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 175-177

We create a new Monte-Carlo design of experiment. On this design of
experiment, the FMU is simulated as well as the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 177-182

.. code-block:: default


    inputTestSample = inputLaw.getSample(10)
    outputFMUTestSample = function(inputTestSample)
    outputMetamodelTestSample = globalMetamodel(inputTestSample)








.. GENERATED FROM PYTHON SOURCE LINES 183-184

First, we have a visual check:

.. GENERATED FROM PYTHON SOURCE LINES 184-204

.. code-block:: default


    gridLayout = ot.GridLayout(1, 2)

    graph1 = outputFMUTestSample.draw().getGraph(0,0)
    graph1.setTitle("FMU simulations")
    graph2 = outputMetamodelTestSample.draw().getGraph(0,0)
    graph2.setTitle("Metamodel")

    for graph in [graph1, graph2]:
        graph.setXTitle("Time")
        graph.setYTitle("Number of infected")
        graph.setLegends(["{:.3f}".format(line[0]) for line in inputSample])

    gridLayout.setGraph(0, 0, graph1)
    gridLayout.setGraph(0, 1, graph2)
    view = viewer.View(gridLayout,
        legend_kw={"title": "infection rate",
        "loc": "upper left"})
    view.ShowAll()




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_003.png
   :alt: , FMU simulations, Metamodel
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 205-206

We validate the pertinence of Karhunen-Loeve decomposition:

.. GENERATED FROM PYTHON SOURCE LINES 206-211

.. code-block:: default


    validationKL = ot.KarhunenLoeveValidation(outputFMUTestSample, resultKL)
    graph = validationKL.computeResidualMean().draw()
    ot.Show(graph)




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_004.png
   :alt: KL residual mean - 0 marginal
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 212-214

As the epidemiological model considers a population size of 700, the residual
mean error on the field is acceptable.

.. GENERATED FROM PYTHON SOURCE LINES 216-218

We validate the Kriging (using the Karhunen-Loeve coefficients of the test
sample):

.. GENERATED FROM PYTHON SOURCE LINES 218-227

.. code-block:: default


    projectFunction = ot.KarhunenLoeveProjection(resultKL)
    coefficientSample = projectFunction(outputFMUTestSample)

    validationKriging = ot.MetaModelValidation(
        inputTestSample, coefficientSample, metamodel)
    Q2 = validationKriging.computePredictivityFactor()[0]
    print(Q2)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.999994931190661




.. GENERATED FROM PYTHON SOURCE LINES 228-232

The predictivity factor is very close to 1, which is satisfying.
Further statistical tests exist in
`OpenTURNS <http://openturns.github.io/openturns/master/contents.html>`_ to
assert the quality of the obtained metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 234-243

----------------------

In this script, we have created and validated the ``globalMetamodel``. This
metamodel (computationnally faster than the FMU) can now be employed instead
of the FMU to perform:

- `sensitivity analysis <http://shorturl.at/dDK24>`_,
- `uncertainty propagation <http://shorturl.at/quFIP>`_,
- `estimate a failure probability <http://shorturl.at/emLQY>`_,
etc.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.351 seconds)


.. _sphx_glr_download_auto_application_plot_metamodel.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_metamodel.py <plot_metamodel.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_metamodel.ipynb <plot_metamodel.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
